import time
import math
import random
from copy import deepcopy

# Import constraint classes
from src.constraints import (
    MinItemsPerSegmentConstraint,
    MaxItemsPerSegmentConstraint,
    ItemFromSegmentAtPositionConstraint,
    ItemAtPositionConstraint,
    GlobalMinItemsPerSegmentConstraint,
    GlobalMaxItemsPerSegmentConstraint,
    MinSegmentsConstraint,
    MaxSegmentsConstraint,
    ItemUniqueness2D
)
from src.algorithms.algorithm import Algorithm


class StateSpaceSolver(Algorithm):
    """
    StateSpaceSolver uses a local search (simulated annealing) over the state space of full recommendation lists.

    A state is a complete configuration: an ordered list of N candidate items.

    The objective function is:
         f(state) = total_score(state) - penalty(state)

    where:
         total_score(state) = sum(score(item) for each item in the state)
         penalty(state) = sum( scale(c) * violation(c, state) for each constraint c )

    Neighbor states are generated by randomly swapping two items or replacing an item.
    The solver runs for a maximum of `time_limit` seconds and returns the best solution found.
    """

    def __init__(self, name="StateSpace", description="State Space Search Solver", verbose=True, time_limit=5.0,
                 max_iterations_no_improvement=1000):
        super().__init__(name, description, verbose)
        self.time_limit = time_limit  # in seconds
        self.max_iterations_no_improvement = max_iterations_no_improvement

    def solve(self, items: dict, segments: dict, constraints: list, N: int, already_recommended_items=None):
        """
        Solve the recommendation problem using state space search.
        :param items: dict mapping item_id to score
        :param segments: dict mapping segment_id to Segment (assumed to support membership tests)
        :param constraints: list of constraint objects (from constraints.py)
        :param N: number of items to recommend (length of state)
        :param already_recommended_items: (optional) list of items already recommended
        :return: dict mapping position (0-indexed) to item_id of best solution found.
        """
        start_time = time.time()
        candidate_item_ids = list(items.keys())

        # initial solution: choose top-N scoring items if available, otherwise fill randomly
        sorted_items = sorted(candidate_item_ids, key=lambda i: items[i], reverse=True)

        # max score = N most scoring items
        max_score = sum(items[i] for i in sorted_items[:N])

        current_state = sorted_items[:N]
        best_state = current_state[:]
        best_value = self.evaluate_state(best_state, items, segments, constraints, max_score)

        # parameters for simulated annealing:
        T0 = 1.0  # initial temperature
        T_min = 1e-3
        alpha = 0.999  # cooling rate
        T = T0

        iterations = 0
        iterations_no_improvement = 0

        while time.time() - start_time < self.time_limit and T > T_min and iterations_no_improvement < self.max_iterations_no_improvement:
            iterations += 1
            iterations_no_improvement += 1
            # Generate a neighbor by a random move (swap or replacement)
            neighbor = self.random_neighbor(current_state, candidate_item_ids)
            neighbor_value = self.evaluate_state(neighbor, items, segments, constraints, max_score)
            current_value = self.evaluate_state(current_state, items, segments, constraints, max_score)
            delta = neighbor_value - current_value

            # accept move if better or with probability if worse
            if delta >= 0 or math.exp(delta / T) > random.random():
                current_state = neighbor[:]

            # update best solution if improved
            current_obj = self.evaluate_state(current_state, items, segments, constraints, max_score)
            if current_obj > best_value:
                best_value = current_obj
                best_state = current_state[:]
                iterations_no_improvement = 0  # Reset counter
                if self.verbose:
                    print(f"[{self.name}] Iteration {iterations}: New best value: {best_value:.2f}")

            # cool down temperature
            T = max(T_min, T * alpha)

        if self.verbose:
            reason = "time limit"
            if T <= T_min:
                reason = "temperature cooled down"
            elif iterations_no_improvement >= self.max_iterations_no_improvement:
                reason = "max iterations without improvement"
            print(
                f"[{self.name}] Finished after {iterations} iterations and {(time.time() - start_time):.2f} seconds. Reason: {reason}. Final T: {T:.4f}")

        # return as a dictionary mapping position to item_id (positions are 0-indexed)
        return {pos: item for pos, item in enumerate(best_state)}

    def evaluate_state(self, state, items, segments, constraints, max_score):
        """Compute the objective value of the state: sum(scores) - penalty"""
        total_score = sum(items[item] for item in state)
        total_penalty = self.compute_total_penalty(state, segments, constraints, max_score)
        return total_score - total_penalty

    def compute_total_penalty(self, state, segments, constraints, max_score):
        """Compute total penalty for all constraints for a given state (state is a list of item_ids)"""
        penalty = 0.0
        for c in constraints:
            penalty += self.compute_penalty_for_constraint(c, state, segments, max_score)
        return penalty

    def compute_penalty_for_constraint(self, c, state, segments, max_score):
        """Compute penalty for a single constraint based on its type"""
        scale = c.weight * max_score
        penalty = 0.0
        N = len(state)

        # handle sliding window constraints based on type:
        if isinstance(c, MinItemsPerSegmentConstraint):
            win = c.window_size
            for i in range(0, N - win + 1):
                window = state[i:i + win]
                count = sum(1 for item in window if item in segments[c.label])
                violation = max(0, c.min_items - count)
                penalty += violation * scale
        elif isinstance(c, MaxItemsPerSegmentConstraint):
            win = c.window_size
            for i in range(0, N - win + 1):
                window = state[i:i + win]
                count = sum(1 for item in window if item in segments[c.label])
                violation = max(0, count - c.max_items)
                penalty += violation * scale
        elif isinstance(c, ItemFromSegmentAtPositionConstraint):
            pos = c.position - 1  # convert to 0-indexed
            if pos < N:
                if state[pos] not in segments[c.label]:
                    penalty += 1 * scale
            else:
                penalty += 1 * scale
        elif isinstance(c, ItemAtPositionConstraint):
            pos = c.position - 1
            if pos < N:
                if state[pos] != c.item_id:
                    penalty += 1 * scale
            else:
                penalty += 1 * scale
        elif isinstance(c, GlobalMinItemsPerSegmentConstraint):
            win = c.window_size
            # use c.min_items for GlobalMinItemsPerSegmentConstraint
            segment_ids = [seg_id for seg_id, seg in segments.items() if
                           getattr(seg, 'property', None) == c.segmentation_property]
            for i in range(0, N - win + 1):
                window = state[i:i + win]
                represented = 0
                for seg_id in segment_ids:
                    if any(item in segments[seg_id] for item in window):
                        represented += 1
                violation = max(0, c.min_items - represented)
                penalty += violation * scale
        elif isinstance(c, MinSegmentsConstraint):
            win = c.window_size
            segment_ids = [seg_id for seg_id, seg in segments.items() if
                           getattr(seg, 'property', None) == c.segmentation_property]
            for i in range(0, N - win + 1):
                window = state[i:i + win]
                represented = 0
                for seg_id in segment_ids:
                    if any(item in segments[seg_id] for item in window):
                        represented += 1
                violation = max(0, c.min_segments - represented)
                penalty += violation * scale
        elif isinstance(c, GlobalMaxItemsPerSegmentConstraint):
            win = c.window_size
            # use c.max_items for GlobalMaxItemsPerSegmentConstraint
            segment_ids = [seg_id for seg_id, seg in segments.items() if
                           getattr(seg, 'property', None) == c.segmentation_property]
            for i in range(0, N - win + 1):
                window = state[i:i + win]
                represented = 0
                for seg_id in segment_ids:
                    if any(item in segments[seg_id] for item in window):
                        represented += 1
                violation = max(0, represented - c.max_items)
                penalty += violation * scale
        elif isinstance(c, MaxSegmentsConstraint):
            win = c.window_size
            segment_ids = [seg_id for seg_id, seg in segments.items() if
                           getattr(seg, 'property', None) == c.segmentation_property]
            for i in range(0, N - win + 1):
                window = state[i:i + win]
                represented = 0
                for seg_id in segment_ids:
                    if any(item in segments[seg_id] for item in window):
                        represented += 1
                violation = max(0, represented - c.max_segments)
                penalty += violation * scale
        else:
            # For any other constraint not explicitly handled, use the check method:
            if not c.check_constraint(state, None, segments):
                penalty += 1 * scale
        return penalty

    def get_scale(self, c):
        """
        Determine a scaling factor for a constraint based on its weight
        """
        if c.weight < 1:
            return c.weight / (1 - c.weight)
        else:
            return 1000  # arbitrarily high for weight 1

    def random_neighbor(self, state, candidate_item_ids):
        """
        Generate a neighbor state from the current state by either swapping two positions or replacing one item
        """
        neighbor = state[:]
        move_type = random.choice(["swap", "replace"])
        N = len(state)
        if move_type == "swap":
            pos1, pos2 = random.sample(range(N), 2)
            neighbor[pos1], neighbor[pos2] = neighbor[pos2], neighbor[pos1]
        else:  # "replace"
            pos = random.randrange(N)
            available = list(set(candidate_item_ids) - set(state))
            if available:
                neighbor[pos] = random.choice(available)
            else:
                pos2 = random.choice([i for i in range(N) if i != pos])
                neighbor[pos], neighbor[pos2] = neighbor[pos2], neighbor[pos]
        return neighbor
